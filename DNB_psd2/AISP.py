#!/usr/bin/env python3
import glob
import json
from datetime import datetime
from socket import gethostbyname, gethostname
from time import sleep
from uuid import uuid4

import requests
from selenium import webdriver
from selenium.webdriver.chrome.options import Options


class AISP:
    __slots__ = 'endpoint', 'date', 's', 'debug', 'consent_payload', 'consent', 'authentication_url'

    def __init__(self, PSU_ID='31125453913'):
        """Initialize the server

        Args:

            PSU_ID (str, optional): [description]. Defaults to '31125453913'.
        """
        self.endpoint = "https://sandboxapi.psd.dnb.no/v1"
        self.date = datetime.date(datetime.now())
        hostname = gethostname()
        local_ip = gethostbyname(hostname)
        headers = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'X-Request-ID': str(uuid4()).lower(),
            # Change the  PSU-ID to change the person and the cards available.
            # List over the PSU-ID can be found:
            # https://developer.dnb.no/documentation/psd2/prod
            'PSU-IP-Address': local_ip,
            'PSU-ID': PSU_ID,
            'TPP-Redirect-URI': 'https://dnb.no'
        }
        self.s = requests.Session()
        self.s.cert = ('./certificate/certificate.pem',
                       './certificate/private.key')
        self.s.headers.update(headers)
        self.post_consents()

    def authenticate(self, url: str) -> None:
        """Authenticate to the server .
        Args:
            url ([string]):[String generated by the DNB api to give consent to the application.]
        """
        webdriver_path = glob.glob("./webdriver/chromedriver*")[0]

        chrome_options = Options()
        chrome_options.add_argument("--headless")
        driver = webdriver.Chrome(
            webdriver_path, options=chrome_options)
        driver.get(self.authentication_url)

        try:
            button = driver.find_elements_by_xpath(r'//*[@id="submit"]')[0]
            button.click()
            sleep(1)
            driver.quit()
        except BaseException:
            print("An error happened. Exiting...")
            driver.quit()

    def post_consents(self) -> None:
        """Creates the consent ID for the user.
        """
        self.consent_payload = {
            # "validUntil": "{{validUntil}}",
            "validUntil": f"{self.date}",
            "frequencyPerDay": 1,
            "access": {
                "balances": [],
                "accounts": [],
                "transactions": []
            },
            "recurringIndicator": "true",
            "combinedServiceIndicator": "false"}

        r = self.s.request(
            "POST",
            url=f"{self.endpoint}/consents",
            data=json.dumps(
                self.consent_payload))

        self.consent = r.json().get("consentId")
        self.s.headers.update({'Consent-ID': self.consent})

        self.authentication_url = r.json().get(
            "_links").get("scaRedirect").get("href")
        self.authenticate(self.authentication_url)

    def delete_consents(self) -> None:
        """Delete the consent for this user.
        """
        r = self.s.request(
            "DELETE",
            url=f"{self.endpoint}/consents/{self.consent}",
            data=self.consent_payload)
        return r.text

    def get_consent(self):
        """Get the current consent .
        """
        r = self.s.request(
            "GET",
            url=f"{self.endpoint}/consents/{self.consent}",
            data=self.consent_payload)
        return r.text()

    def accounts(self) -> list:
        """Get a list of bban accounts .
        Returns:
            list: [List containing all the different bank account numbers]
        """
        payload = {}
        r = self.s.request(
            "GET", url=f"{self.endpoint}/accounts", data=payload)
        # Return a list with the different account numbers
        return [i.get('bban') for i in r.json().get('accounts')]

    def get_account_info(self, account: int) -> None:
        """Get account information.
        Args:
            account (int): [account/bban nr]
        """
        r = self.s.request(
            "GET", url=f"{self.endpoint}/accounts/{account}", data={})
        return r.json()

    def get_bank_transactions(
            self,
            account: int) -> dict:
        """Returns a list of of bban, pending and booked transactions .
        Args:
            account (int): [The account we want to extract transactions from]
            preprocessed (bool, optional): [Option to let the funciton preprocess the data for the user]. Defaults to False.
        Returns:
            dict: [Either one dict containing the trans info, or a preprocessed dict splitt up for easy of use.]
        """
        r = self.s.request(
            "GET",
            url=f"{self.endpoint}/accounts/{account}/transactions?bookingStatus=both&dateFrom=2000-01-01",
            data={})
        return r.json()

    def get_card(self) -> list:
        """Get a list of card accounts .
        Returns:
            list: [List containing all the different bank account numbers]
        """
        payload = {}
        r = self.s.request(
            "GET", url=f"{self.endpoint}/card-accounts", data=payload)
        # Return a list with the different account numbers
        return [i.get('resourceId') for i in r.json().get('cardAccounts')]

    def get_card_transactions(self, account: int) -> None:
        """Returns the current user's card transactions .
        Args:
            account (int): [description]
        """
        r = self.s.request(
            "GET",
            url=f"{self.endpoint}/card-accounts/{account}/transactions?bookingStatus=both&dateFrom=2019-01-01",
            data={})
        return r.text

    def go_trough_card_transactions(self, cards):
        """Go through the cards available for the current accounts/SSID user .
        Args:
            cards ([type]): [description]
        """
        for i in range(len(cards)):
            self.get_card_transactions(cards[i])

    def read_account_balance(self, bban):
        """Returns a json/dictionary of the account balance
        Args:
            bban (str): Account-number (bban)
        """
        r = self.s.request(
            "GET",
            url=f"{self.endpoint}/accounts/{bban}/balances",
            data={})
        return r.json()
